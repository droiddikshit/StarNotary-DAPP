no// file: WidgetHostController.kt
package com.example.mynewwidget

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.content.Context
import android.os.Bundle
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner

class WidgetHostController(
    private val appContext: Context,
    private val hostId: Int = 1024
) : DefaultLifecycleObserver {

    val appWidgetManager: AppWidgetManager = AppWidgetManager.getInstance(appContext)
    val appWidgetHost: AppWidgetHost = AppWidgetHost(appContext, hostId)

    override fun onStart(owner: LifecycleOwner) {
        appWidgetHost.startListening()
    }

    override fun onStop(owner: LifecycleOwner) {
        appWidgetHost.stopListening()
    }

    /** Call this after your host view has a non-zero size (post {} after layout or onMove). */
    fun applySize(hostView: AppWidgetHostView) {
        val w = hostView.width
        val h = hostView.height
        if (w <= 0 || h <= 0) return

        val d = hostView.resources.displayMetrics.density
        val opts = Bundle().apply {
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, (h / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, (h / d).toInt())
        }
        hostView.updateAppWidgetOptions(opts)
        hostView.updateAppWidgetSize(
            opts,
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT)
        )
    }
}




// In your pager page view or the place where you currently create the widgets:
class WidgetPageView(context: Context) : FrameLayout(context) {

    private val controller = WidgetHostController(context.applicationContext)
    private val appWidgetManager get() = controller.appWidgetManager
    private val appWidgetHost get() = controller.appWidgetHost

    init {
        // Bind to lifecycle if available (ViewPager2 + Fragment -> this is non-null)
        androidx.lifecycle.ViewTreeLifecycleOwner.get(this)?.lifecycle?.addObserver(controller)

        // Fallback: if no lifecycle owner exists, manage start/stop by visibility
        addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
            override fun onViewAttachedToWindow(v: android.view.View) {
                if (androidx.lifecycle.ViewTreeLifecycleOwner.get(this@WidgetPageView) == null) {
                    appWidgetHost.startListening()
                }
            }
            override fun onViewDetachedFromWindow(v: android.view.View) {
                if (androidx.lifecycle.ViewTreeLifecycleOwner.get(this@WidgetPageView) == null) {
                    appWidgetHost.stopListening()
                }
            }
        })
    }

    // Important for pagers: fragment/page visibility flips without detach. Handle both:
    override fun onWindowVisibilityChanged(visibility: Int) {
        super.onWindowVisibilityChanged(visibility)
        val hasLifecycle = androidx.lifecycle.ViewTreeLifecycleOwner.get(this) != null
        if (!hasLifecycle) {
            if (visibility == VISIBLE) appWidgetHost.startListening() else appWidgetHost.stopListening()
        }
    }

    override fun onVisibilityAggregated(isVisible: Boolean) { // ViewPager2 path
        super.onVisibilityAggregated(isVisible)
        val hasLifecycle = androidx.lifecycle.ViewTreeLifecycleOwner.get(this) != null
        if (!hasLifecycle) {
            if (isVisible) appWidgetHost.startListening() else appWidgetHost.stopListening()
        }
    }

    /** When user picks a widget: */
    fun addWidget(provider: AppWidgetProviderInfo, widgetId: Int) {
        val w = provider.minWidth.coerceAtLeast(400)
        val h = provider.minHeight.coerceAtLeast(400)

        val hostView = appWidgetHost.createView(context, widgetId, provider).apply {
            setAppWidget(widgetId, provider)
            layoutParams = LayoutParams(w, h)
        }

        val container = FrameLayout(context).apply {
            layoutParams = LayoutParams(w, h)
            x = 100f; y = 100f
            addView(hostView)
            // keep your touch listener etc.
        }

        addView(container)

        // Key bit for Samsung: apply size AFTER it's laid out (next frame), and again when moved/resized.
        container.post {
            controller.applySize(hostView)
        }
    }

    /** Launch your existing bottom sheet, but use controllerâ€™s host/manager */
    fun showPicker() {
        WidgetPickerBottomSheet(
            context = context,
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            addWidget(provider, widgetId)
        }.show()
    }
}




// Wherever you know the "selected page" signal:
fun onPageSelected(isSelected: Boolean) {
    if (isSelected) controller.appWidgetHost.startListening()
    else controller.appWidgetHost.stopListening()
}





// inside your adapterâ€™s onBindViewHolder in the bottom sheet:
val widgetId = appWidgetHost.allocateAppWidgetId()
val bound = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
if (!bound) {
    appWidgetHost.deleteAppWidgetId(widgetId)
    return
}
// on sheet dismiss without selection:
bottomSheet.setOnDismissListener {
    // delete any preview-only allocated ids you tracked
}



dependencies {
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:<latest>"
    implementation "androidx.lifecycle:lifecycle-common-java8:<latest>"
    // If you use ViewPager2 with Fragments, you already transitively have lifecycle, but keep these explicit.
}



// file: WidgetHostController.kt
package com.example.mynewwidget

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.content.Context
import android.os.Bundle
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner

class WidgetHostController(
    appContext: Context,
    hostId: Int = 1024
) : DefaultLifecycleObserver {

    val appWidgetManager: AppWidgetManager = AppWidgetManager.getInstance(appContext)
    val appWidgetHost: AppWidgetHost = AppWidgetHost(appContext, hostId)

    override fun onStart(owner: LifecycleOwner) { appWidgetHost.startListening() }
    override fun onStop(owner: LifecycleOwner)  { appWidgetHost.stopListening()  }

    fun applySize(hostView: AppWidgetHostView) {
        val w = hostView.width; val h = hostView.height
        if (w <= 0 || h <= 0) return
        val d = hostView.resources.displayMetrics.density
        val opts = Bundle().apply {
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, (h / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, (h / d).toInt())
        }
        hostView.updateAppWidgetOptions(opts)
        hostView.updateAppWidgetSize(
            opts,
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT)
        )
    }
}





// file: WidgetPageView.kt
package com.example.mynewwidget

import android.annotation.SuppressLint
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.lifecycle.ViewTreeLifecycleOwner
import kotlin.math.max

class WidgetPageView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null
) : FrameLayout(context, attrs) {

    private val controller = WidgetHostController(context.applicationContext)
    private val appWidgetManager get() = controller.appWidgetManager
    private val appWidgetHost get() = controller.appWidgetHost

    private val canvas = FrameLayout(context)
    private val deleteZone = ImageView(context).apply {
        setImageResource(android.R.drawable.ic_menu_delete)
        layoutParams = LayoutParams(dp(48), dp(48), Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL)
        visibility = View.GONE; alpha = 0.85f; elevation = dp(8).toFloat()
    }
    private val addBtn = TextView(context).apply {
        text = "âž• Add Widget"; textSize = 16f
        setBackgroundColor(0xFF3F51B5.toInt()); setTextColor(0xFFFFFFFF.toInt())
        setPadding(dp(16), dp(8), dp(16), dp(8))
        layoutParams = LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.TOP or Gravity.CENTER_HORIZONTAL)
        elevation = dp(8).toFloat()
        setOnClickListener { showPicker() }
    }

    init {
        isClickable = true; isFocusable = true
        addView(canvas, LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT))
        addView(addBtn); addView(deleteZone)

        // Attach controller to the page's lifecycle (this is the androidx bit you now have)
        ViewTreeLifecycleOwner.get(this)?.lifecycle?.addObserver(controller)

        // Fallback if owner not yet available at init: register when attached.
        addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
            override fun onViewAttachedToWindow(v: View) {
                ViewTreeLifecycleOwner.get(this@WidgetPageView)?.lifecycle?.addObserver(controller)
            }
            override fun onViewDetachedFromWindow(v: View) { /* lifecycle removes observers automatically */ }
        })
    }

    private fun dp(v: Int) = (v * resources.displayMetrics.density).toInt()

    private fun showPicker() {
        WidgetPickerBottomSheet(
            context = context,
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            addWidget(provider, widgetId)
        }.show()
    }

    fun addWidget(provider: AppWidgetProviderInfo, widgetId: Int) {
        val w = max(provider.minWidth, 400)
        val h = max(provider.minHeight, 400)
        val hostView = appWidgetHost.createView(context, widgetId, provider).apply {
            setAppWidget(widgetId, provider)
            layoutParams = LayoutParams(w, h)
        }
        val container = FrameLayout(context).apply {
            layoutParams = LayoutParams(w, h)
            x = dp(100).toFloat(); y = dp(100).toFloat()
            addView(hostView)
            setOnTouchListener(touchListener(this, widgetId, provider))
        }
        canvas.addView(container)

        // Samsung: size negotiation AFTER layout (next frame) and after moves
        container.post { controller.applySize(hostView as AppWidgetHostView) }
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun touchListener(widget: View, widgetId: Int, provider: AppWidgetProviderInfo): OnTouchListener {
        var dX = 0f; var dY = 0f; var dragging = false
        return OnTouchListener { _, e ->
            when (e.action) {
                MotionEvent.ACTION_DOWN -> { dX = widget.x - e.rawX; dY = widget.y - e.rawY; dragging = false; true }
                MotionEvent.ACTION_MOVE -> { widget.x = e.rawX + dX; widget.y = e.rawY + dY; deleteZone.visibility = View.VISIBLE; dragging = true; true }
                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        Toast.makeText(context, "ðŸ—‘ï¸ Widget Removed", Toast.LENGTH_SHORT).show()
                    } else if (dragging) {
                        (widget.getChildAt(0) as? AppWidgetHostView)?.let { controller.applySize(it) }
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun isOverDeleteZone(view: View): Boolean {
        val zone = Rect()
        deleteZone.getGlobalVisibleRect(zone)
        val loc = IntArray(2); getLocationOnScreen(loc)
        val cx = (view.x + view.width / 2).toInt() + loc[0]
        val cy = (view.y + view.height / 2).toInt() + loc[1]
        return zone.contains(cx, cy)
    }
}



dependencies {
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.8.4"
    implementation "androidx.lifecycle:lifecycle-common-java8:2.8.4" // for DefaultLifecycleObserver
    // (optional but usual in pager+fragments projects)
    implementation "androidx.fragment:fragment-ktx:1.7.1"
    implementation "androidx.activity:activity-ktx:1.9.2"
}


import androidx.lifecycle.ViewTreeLifecycleOwner



dependencies {
    // EITHER use the BOM â€¦
    implementation(platform("androidx.lifecycle:lifecycle-bom:2.8.4"))
    implementation("androidx.lifecycle:lifecycle-runtime")          // <- contains ViewTreeLifecycleOwner
    implementation("androidx.lifecycle:lifecycle-runtime-ktx")      // optional
    implementation("androidx.lifecycle:lifecycle-common-java8")     // for DefaultLifecycleObserver

    // â€¦ OR pin the exact artifact:
    // implementation "androidx.lifecycle:lifecycle-runtime:2.8.4"
}











package your.package.name

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.view.Gravity
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.TextView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialog

/**
 * BottomSheet that shows live widget previews using a RecyclerView grid.
 * Allocation/binding happens on attach; resources are released on detach.
 */
class WidgetPickerBottomSheet(
    private val context: Context,
    private val appWidgetManager: AppWidgetManager,
    private val appWidgetHost: AppWidgetHost,
    private val onWidgetSelected: (AppWidgetProviderInfo, Int) -> Unit
) {

    fun show() {
        val sheet = BottomSheetDialog(context)
        val rv = RecyclerView(context).apply {
            layoutManager = GridLayoutManager(context, 2)
            setHasFixedSize(true)
        }

        val providers: List<AppWidgetProviderInfo> = appWidgetManager.installedProviders

        rv.adapter = object : RecyclerView.Adapter<WidgetCellVH>() {

            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): WidgetCellVH {
                val cellHeightPx = (200 * parent.resources.displayMetrics.density).toInt()
                val root = FrameLayout(parent.context).apply {
                    layoutParams = ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        cellHeightPx
                    )
                    isClickable = true
                }
                return WidgetCellVH(root)
            }

            override fun onBindViewHolder(holder: WidgetCellVH, position: Int) {
                holder.bind(providers[position], onWidgetSelected)
            }

            override fun getItemCount(): Int = providers.size

            // --- lifecycle-aware binding to avoid flicker/blank states ---
            override fun onViewAttachedToWindow(holder: WidgetCellVH) {
                holder.attach(appWidgetHost, appWidgetManager)
            }

            override fun onViewDetachedFromWindow(holder: WidgetCellVH) {
                holder.detach(appWidgetHost)
            }

            override fun onViewRecycled(holder: WidgetCellVH) {
                holder.detach(appWidgetHost)
                super.onViewRecycled(holder)
            }
        }

        sheet.setContentView(rv)
        sheet.show()
    }

    private class WidgetCellVH(val root: FrameLayout) : RecyclerView.ViewHolder(root) {
        private var provider: AppWidgetProviderInfo? = null
        private var widgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID
        private var hostView: AppWidgetHostView? = null

        fun bind(
            prov: AppWidgetProviderInfo,
            onPick: (AppWidgetProviderInfo, Int) -> Unit
        ) {
            provider = prov
            root.setOnClickListener {
                val id = if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID)
                    AppWidgetManager.INVALID_APPWIDGET_ID else widgetId
                // If we haven't attached yet, weâ€™ll allocate in attach();
                // if already attached, id is valid and we can return immediately.
                onPick(prov, if (id != AppWidgetManager.INVALID_APPWIDGET_ID) id else widgetId)
            }
        }

        fun attach(host: AppWidgetHost, mgr: AppWidgetManager) {
            val p = provider ?: return

            if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                widgetId = host.allocateAppWidgetId()
            }

            val bound = mgr.bindAppWidgetIdIfAllowed(widgetId, p.provider)

            root.removeAllViews()

            if (bound) {
                hostView = host.createView(root.context, widgetId, p).apply {
                    setAppWidget(widgetId, p)
                    layoutParams = FrameLayout.LayoutParams(p.minWidth, p.minHeight, Gravity.CENTER)
                }
                root.addView(hostView)
            } else {
                // Fallback label if user hasnâ€™t granted bind permission (non-system builds).
                root.addView(TextView(root.context).apply {
                    text = p.loadLabel(root.context.packageManager)
                    gravity = Gravity.CENTER
                    layoutParams = FrameLayout.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                })
            }
        }

        fun detach(host: AppWidgetHost) {
            root.removeAllViews()
            hostView = null
            if (widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                host.deleteAppWidgetId(widgetId)
                widgetId = AppWidgetManager.INVALID_APPWIDGET_ID
            }
        }
    }
}











package your.package.name

import android.annotation.SuppressLint
import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.graphics.Rect
import android.os.Bundle
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.Toast
import androidx.fragment.app.Fragment

/**
 * Fragment that owns the AppWidgetHost lifecycle and surface where a picked widget is placed.
 * Layout must define:
 *   - R.layout.widget_fragment_layout
 *   - a Button (or any clickable view) with id R.id.add_widget_button
 *   - a FrameLayout with id R.id.widgets_fragment_container (the canvas)
 */
class WidgetsFragment : Fragment(R.layout.widget_fragment_layout) {

    private lateinit var appWidgetManager: AppWidgetManager
    private lateinit var appWidgetHost: AppWidgetHost

    private lateinit var addWidgetBtn: View
    private lateinit var widgetsLayoutContainer: FrameLayout
    private lateinit var deleteZone: ImageView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        appWidgetManager = AppWidgetManager.getInstance(requireContext())
        appWidgetHost = AppWidgetHost(requireContext(), /*hostId=*/1024)
        // no startListening() here; do it in onStart()
    }

    override fun onStart() {
        super.onStart()
        appWidgetHost.startListening()
    }

    override fun onStop() {
        super.onStop()
        appWidgetHost.stopListening()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        addWidgetBtn = view.findViewById(R.id.add_widget_button)
        widgetsLayoutContainer = view.findViewById(R.id.widgets_fragment_container)

        // Optional: a simple bottom "trash" area for drag-to-delete.
        deleteZone = ImageView(requireContext()).apply {
            setImageResource(android.R.drawable.ic_menu_delete)
            alpha = 0.8f
            visibility = View.GONE
            layoutParams = FrameLayout.LayoutParams(
                resources.displayMetrics.widthPixels,
                (56 * resources.displayMetrics.density).toInt(),
                Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            )
        }
        (view as ViewGroup).addView(deleteZone)

        addWidgetBtn.setOnClickListener { showWidgetPickerBottomSheet() }
    }

    private fun showWidgetPickerBottomSheet() {
        WidgetPickerBottomSheet(
            context = requireActivity(),                 // Activity context is safer for some providers
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            // Called when user taps a cell in the sheet
            addWidgetToSurface(provider, widgetId)
        }.show()
    }

    private fun addWidgetToSurface(provider: AppWidgetProviderInfo, widgetId: Int) {
        // Ensure bound (no-op if already bound)
        if (!appWidgetManager.isBoundAppWidget(widgetId)) {
            val ok = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
            if (!ok) {
                Toast.makeText(requireContext(), "Binding not allowed", Toast.LENGTH_SHORT).show()
                return
            }
        }

        val hostView: AppWidgetHostView = appWidgetHost.createView(requireActivity(), widgetId, provider).apply {
            setAppWidget(widgetId, provider)
            layoutParams = FrameLayout.LayoutParams(provider.minWidth, provider.minHeight)
        }

        widgetsLayoutContainer.addView(hostView)

        // Optional: simple drag + delete interaction
        hostView.setOnTouchListener(widgetTouchListener(hostView, widgetId))
    }

    // --- Simple drag + delete (optional) ---

    @SuppressLint("ClickableViewAccessibility")
    private fun widgetTouchListener(widget: View, widgetId: Int): View.OnTouchListener {
        var dX = 0f
        var dY = 0f
        var dragging = false

        return View.OnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    dX = widget.x - event.rawX
                    dY = widget.y - event.rawY
                    dragging = false
                    true
                }

                MotionEvent.ACTION_MOVE -> {
                    widget.x = event.rawX + dX
                    widget.y = event.rawY + dY
                    deleteZone.visibility = View.VISIBLE
                    dragging = true
                    true
                }

                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (dragging && isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        appWidgetHost.deleteAppWidgetId(widgetId)
                        Toast.makeText(requireContext(), "Widget removed", Toast.LENGTH_SHORT).show()
                    }
                    true
                }

                else -> false
            }
        }
    }

    private fun isOverDeleteZone(v: View): Boolean {
        val trashRect = Rect()
        deleteZone.getHitRect(trashRect)
        val viewRect = Rect(
            v.x.toInt(), v.y.toInt(),
            (v.x + v.width).toInt(), (v.y + v.height).toInt()
        )
        return Rect.intersects(trashRect, viewRect)
    }
}

/** Helper: treat non-null info as â€œboundâ€. */
private fun AppWidgetManager.isBoundAppWidget(id: Int): Boolean = getAppWidgetInfo(id) != null















package your.package.name

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.util.Log
import android.view.Gravity
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.TextView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialog

/**
 * BottomSheet widget picker that shows live previews.
 * - Allocates/binds on attach; releases on detach.
 * - When user picks a cell, marks it "consumed" so the id survives sheet dismiss.
 */
class WidgetPickerBottomSheet(
    private val context: Context,
    private val appWidgetManager: AppWidgetManager,
    private val appWidgetHost: AppWidgetHost,
    private val onWidgetSelected: (AppWidgetProviderInfo, Int) -> Unit
) {
    private val tag = "WidgetPickerSheet"

    fun show() {
        val sheet = BottomSheetDialog(context)
        val rv = RecyclerView(context).apply {
            layoutManager = GridLayoutManager(context, 2)
            setHasFixedSize(true)
        }

        val providers: List<AppWidgetProviderInfo> = appWidgetManager.installedProviders

        rv.adapter = object : RecyclerView.Adapter<VH>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
                val cellHeightPx = (200 * parent.resources.displayMetrics.density).toInt()
                val root = FrameLayout(parent.context).apply {
                    layoutParams = ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        cellHeightPx
                    )
                    isClickable = true
                }
                return VH(root)
            }

            override fun onBindViewHolder(holder: VH, position: Int) {
                holder.bind(providers[position]) { prov, id ->
                    // 1) hand off the id to caller
                    onWidgetSelected(prov, id)
                    // 2) dismiss AFTER handoff (detach will run but skip deletion)
                    sheet.dismiss()
                }
            }

            override fun getItemCount() = providers.size

            override fun onViewAttachedToWindow(holder: VH) {
                holder.attach(appWidgetHost, appWidgetManager)
            }

            override fun onViewDetachedFromWindow(holder: VH) {
                holder.detach(appWidgetHost)
            }

            override fun onViewRecycled(holder: VH) {
                holder.detach(appWidgetHost)
                super.onViewRecycled(holder)
            }
        }

        sheet.setContentView(rv)
        sheet.show()
    }

    private inner class VH(val root: FrameLayout) : RecyclerView.ViewHolder(root) {
        private var provider: AppWidgetProviderInfo? = null
        private var widgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID
        private var hostView: AppWidgetHostView? = null

        /** If true, don't delete id on detach (user has picked this cell). */
        private var consumedByPick = false

        fun bind(
            prov: AppWidgetProviderInfo,
            onPick: (AppWidgetProviderInfo, Int) -> Unit
        ) {
            provider = prov
            consumedByPick = false

            root.setOnClickListener {
                val p = provider ?: return@setOnClickListener

                // If user taps before attach, allocate now.
                if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                    widgetId = appWidgetHost.allocateAppWidgetId()
                }

                // Try to bind silently; OK if false (Fragment will show system sheet).
                appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, p.provider)

                consumedByPick = true  // keep the id alive after dismiss
                onPick(p, widgetId)
            }
        }

        fun attach(host: AppWidgetHost, mgr: AppWidgetManager) {
            val p = provider ?: return

            if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                widgetId = host.allocateAppWidgetId()
                Log.d(tag, "allocate id=$widgetId for ${p.provider}")
            }

            val bound = mgr.bindAppWidgetIdIfAllowed(widgetId, p.provider)
            root.removeAllViews()

            if (bound) {
                hostView = host.createView(root.context, widgetId, p).apply {
                    setAppWidget(widgetId, p)
                    layoutParams = FrameLayout.LayoutParams(
                        p.minWidth, p.minHeight, Gravity.CENTER
                    )
                }
                root.addView(hostView)
            } else {
                // Fallback label if we can't bind silently (non-system app)
                root.addView(TextView(root.context).apply {
                    text = p.loadLabel(root.context.packageManager)
                    gravity = Gravity.CENTER
                    layoutParams = FrameLayout.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                })
            }
        }

        fun detach(host: AppWidgetHost) {
            root.removeAllViews()
            hostView = null
            if (!consumedByPick && widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                host.deleteAppWidgetId(widgetId)
                widgetId = AppWidgetManager.INVALID_APPWIDGET_ID
            }
        }
    }
}







package your.package.name

import android.annotation.SuppressLint
import android.app.Activity
import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Intent
import android.graphics.Rect
import android.os.Bundle
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.fragment.app.Fragment

/**
 * Fragment that owns the AppWidgetHost lifecycle and canvas for placed widgets.
 * Layout requirements:
 *  - R.layout.widget_fragment_layout
 *  - View id R.id.add_widget_button
 *  - FrameLayout id R.id.widgets_fragment_container
 */
class WidgetsFragment : Fragment(R.layout.widget_fragment_layout) {

    private lateinit var appWidgetManager: AppWidgetManager
    private lateinit var appWidgetHost: AppWidgetHost

    private lateinit var addWidgetBtn: View
    private lateinit var widgetsLayoutContainer: FrameLayout
    private lateinit var deleteZone: ImageView

    // Store pending selection when we need to ask system to grant bind permission
    private var pendingProvider: AppWidgetProviderInfo? = null
    private var pendingWidgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID

    // ActivityResult launcher for ACTION_APPWIDGET_BIND
    private val bindWidgetLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val id = result.data?.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1) ?: -1
            val info = if (id > 0) appWidgetManager.getAppWidgetInfo(id) else pendingProvider?.let {
                // Some OEMs don't echo back id; fall back to our pending id.
                appWidgetManager.getAppWidgetInfo(pendingWidgetId)
            }

            val finalId = if (id > 0) id else pendingWidgetId
            val finalInfo = info ?: pendingProvider
            if (finalInfo != null && finalId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                addWidgetToSurface(finalInfo, finalId)
            } else {
                Toast.makeText(requireContext(), "Binding canceled", Toast.LENGTH_SHORT).show()
            }
        } else {
            Toast.makeText(requireContext(), "Binding denied", Toast.LENGTH_SHORT).show()
        }

        // clear pending state
        pendingProvider = null
        pendingWidgetId = AppWidgetManager.INVALID_APPWIDGET_ID
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        appWidgetManager = AppWidgetManager.getInstance(requireContext())
        appWidgetHost = AppWidgetHost(requireContext(), /*hostId=*/1024)
    }

    override fun onStart() {
        super.onStart()
        appWidgetHost.startListening()
    }

    override fun onStop() {
        super.onStop()
        appWidgetHost.stopListening()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        addWidgetBtn = view.findViewById(R.id.add_widget_button)
        widgetsLayoutContainer = view.findViewById(R.id.widgets_fragment_container)

        // Optional trash zone for drag-to-delete
        deleteZone = ImageView(requireContext()).apply {
            setImageResource(android.R.drawable.ic_menu_delete)
            alpha = 0.85f
            visibility = View.GONE
            layoutParams = FrameLayout.LayoutParams(
                resources.displayMetrics.widthPixels,
                (56 * resources.displayMetrics.density).toInt(),
                Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            )
        }
        (view as ViewGroup).addView(deleteZone)

        addWidgetBtn.setOnClickListener { showWidgetPickerBottomSheet() }
    }

    private fun showWidgetPickerBottomSheet() {
        WidgetPickerBottomSheet(
            context = requireActivity(),
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            // Ensure we are allowed; if not, launch system grant UI.
            if (!ensureBindOrRequest(provider, widgetId)) return@WidgetPickerBottomSheet
            addWidgetToSurface(provider, widgetId)
        }.show()
    }

    /**
     * Try to bind silently; if not allowed, launch ACTION_APPWIDGET_BIND.
     * Returns true if already bound/allowed, false if flow continues via launcher.
     */
    private fun ensureBindOrRequest(provider: AppWidgetProviderInfo, widgetId: Int): Boolean {
        val ok = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
        if (ok) return true

        // Request user approval via system UI
        pendingProvider = provider
        pendingWidgetId = widgetId

        val intent = Intent(AppWidgetManager.ACTION_APPWIDGET_BIND).apply {
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widgetId)
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, provider.provider)
            // Optional: restrict to categories supported by the host
            // putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE, UserHandle.myUserId())
        }
        bindWidgetLauncher.launch(intent)
        return false
    }

    private fun addWidgetToSurface(provider: AppWidgetProviderInfo, widgetId: Int) {
        // Double-check bound (some OEMs require this even after approval)
        if (appWidgetManager.getAppWidgetInfo(widgetId) == null) {
            val ok = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
            if (!ok) {
                Toast.makeText(requireContext(), "Binding not allowed", Toast.LENGTH_SHORT).show()
                return
            }
        }

        val hostView: AppWidgetHostView =
            appWidgetHost.createView(requireActivity(), widgetId, provider).apply {
                setAppWidget(widgetId, provider)
                layoutParams = FrameLayout.LayoutParams(provider.minWidth, provider.minHeight)
            }

        widgetsLayoutContainer.addView(hostView)
        hostView.setOnTouchListener(widgetTouchListener(hostView, widgetId))
    }

    // ------------ Optional drag + delete UX ------------

    @SuppressLint("ClickableViewAccessibility")
    private fun widgetTouchListener(widget: View, widgetId: Int): View.OnTouchListener {
        var dX = 0f
        var dY = 0f
        var dragging = false

        return View.OnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    dX = widget.x - event.rawX
                    dY = widget.y - event.rawY
                    dragging = false
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    widget.x = event.rawX + dX
                    widget.y = event.rawY + dY
                    deleteZone.visibility = View.VISIBLE
                    dragging = true
                    true
                }
                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (dragging && isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        appWidgetHost.deleteAppWidgetId(widgetId)
                        Toast.makeText(requireContext(), "Widget removed", Toast.LENGTH_SHORT).show()
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun isOverDeleteZone(v: View): Boolean {
        val trashRect = Rect()
        deleteZone.getHitRect(trashRect)
        val viewRect = Rect(
            v.x.toInt(), v.y.toInt(),
            (v.x + v.width).toInt(), (v.y + v.height).toInt()
        )
        return Rect.intersects(trashRect, viewRect)
    }
}

----










