no// file: WidgetHostController.kt
package com.example.mynewwidget

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.content.Context
import android.os.Bundle
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner

class WidgetHostController(
    private val appContext: Context,
    private val hostId: Int = 1024
) : DefaultLifecycleObserver {

    val appWidgetManager: AppWidgetManager = AppWidgetManager.getInstance(appContext)
    val appWidgetHost: AppWidgetHost = AppWidgetHost(appContext, hostId)

    override fun onStart(owner: LifecycleOwner) {
        appWidgetHost.startListening()
    }

    override fun onStop(owner: LifecycleOwner) {
        appWidgetHost.stopListening()
    }

    /** Call this after your host view has a non-zero size (post {} after layout or onMove). */
    fun applySize(hostView: AppWidgetHostView) {
        val w = hostView.width
        val h = hostView.height
        if (w <= 0 || h <= 0) return

        val d = hostView.resources.displayMetrics.density
        val opts = Bundle().apply {
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, (h / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, (h / d).toInt())
        }
        hostView.updateAppWidgetOptions(opts)
        hostView.updateAppWidgetSize(
            opts,
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT)
        )
    }
}




// In your pager page view or the place where you currently create the widgets:
class WidgetPageView(context: Context) : FrameLayout(context) {

    private val controller = WidgetHostController(context.applicationContext)
    private val appWidgetManager get() = controller.appWidgetManager
    private val appWidgetHost get() = controller.appWidgetHost

    init {
        // Bind to lifecycle if available (ViewPager2 + Fragment -> this is non-null)
        androidx.lifecycle.ViewTreeLifecycleOwner.get(this)?.lifecycle?.addObserver(controller)

        // Fallback: if no lifecycle owner exists, manage start/stop by visibility
        addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
            override fun onViewAttachedToWindow(v: android.view.View) {
                if (androidx.lifecycle.ViewTreeLifecycleOwner.get(this@WidgetPageView) == null) {
                    appWidgetHost.startListening()
                }
            }
            override fun onViewDetachedFromWindow(v: android.view.View) {
                if (androidx.lifecycle.ViewTreeLifecycleOwner.get(this@WidgetPageView) == null) {
                    appWidgetHost.stopListening()
                }
            }
        })
    }

    // Important for pagers: fragment/page visibility flips without detach. Handle both:
    override fun onWindowVisibilityChanged(visibility: Int) {
        super.onWindowVisibilityChanged(visibility)
        val hasLifecycle = androidx.lifecycle.ViewTreeLifecycleOwner.get(this) != null
        if (!hasLifecycle) {
            if (visibility == VISIBLE) appWidgetHost.startListening() else appWidgetHost.stopListening()
        }
    }

    override fun onVisibilityAggregated(isVisible: Boolean) { // ViewPager2 path
        super.onVisibilityAggregated(isVisible)
        val hasLifecycle = androidx.lifecycle.ViewTreeLifecycleOwner.get(this) != null
        if (!hasLifecycle) {
            if (isVisible) appWidgetHost.startListening() else appWidgetHost.stopListening()
        }
    }

    /** When user picks a widget: */
    fun addWidget(provider: AppWidgetProviderInfo, widgetId: Int) {
        val w = provider.minWidth.coerceAtLeast(400)
        val h = provider.minHeight.coerceAtLeast(400)

        val hostView = appWidgetHost.createView(context, widgetId, provider).apply {
            setAppWidget(widgetId, provider)
            layoutParams = LayoutParams(w, h)
        }

        val container = FrameLayout(context).apply {
            layoutParams = LayoutParams(w, h)
            x = 100f; y = 100f
            addView(hostView)
            // keep your touch listener etc.
        }

        addView(container)

        // Key bit for Samsung: apply size AFTER it's laid out (next frame), and again when moved/resized.
        container.post {
            controller.applySize(hostView)
        }
    }

    /** Launch your existing bottom sheet, but use controllerâ€™s host/manager */
    fun showPicker() {
        WidgetPickerBottomSheet(
            context = context,
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            addWidget(provider, widgetId)
        }.show()
    }
}




// Wherever you know the "selected page" signal:
fun onPageSelected(isSelected: Boolean) {
    if (isSelected) controller.appWidgetHost.startListening()
    else controller.appWidgetHost.stopListening()
}





// inside your adapterâ€™s onBindViewHolder in the bottom sheet:
val widgetId = appWidgetHost.allocateAppWidgetId()
val bound = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
if (!bound) {
    appWidgetHost.deleteAppWidgetId(widgetId)
    return
}
// on sheet dismiss without selection:
bottomSheet.setOnDismissListener {
    // delete any preview-only allocated ids you tracked
}



dependencies {
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:<latest>"
    implementation "androidx.lifecycle:lifecycle-common-java8:<latest>"
    // If you use ViewPager2 with Fragments, you already transitively have lifecycle, but keep these explicit.
}



// file: WidgetHostController.kt
package com.example.mynewwidget

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.content.Context
import android.os.Bundle
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner

class WidgetHostController(
    appContext: Context,
    hostId: Int = 1024
) : DefaultLifecycleObserver {

    val appWidgetManager: AppWidgetManager = AppWidgetManager.getInstance(appContext)
    val appWidgetHost: AppWidgetHost = AppWidgetHost(appContext, hostId)

    override fun onStart(owner: LifecycleOwner) { appWidgetHost.startListening() }
    override fun onStop(owner: LifecycleOwner)  { appWidgetHost.stopListening()  }

    fun applySize(hostView: AppWidgetHostView) {
        val w = hostView.width; val h = hostView.height
        if (w <= 0 || h <= 0) return
        val d = hostView.resources.displayMetrics.density
        val opts = Bundle().apply {
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH,  (w / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, (h / d).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, (h / d).toInt())
        }
        hostView.updateAppWidgetOptions(opts)
        hostView.updateAppWidgetSize(
            opts,
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),
            opts.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT)
        )
    }
}





// file: WidgetPageView.kt
package com.example.mynewwidget

import android.annotation.SuppressLint
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.lifecycle.ViewTreeLifecycleOwner
import kotlin.math.max

class WidgetPageView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null
) : FrameLayout(context, attrs) {

    private val controller = WidgetHostController(context.applicationContext)
    private val appWidgetManager get() = controller.appWidgetManager
    private val appWidgetHost get() = controller.appWidgetHost

    private val canvas = FrameLayout(context)
    private val deleteZone = ImageView(context).apply {
        setImageResource(android.R.drawable.ic_menu_delete)
        layoutParams = LayoutParams(dp(48), dp(48), Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL)
        visibility = View.GONE; alpha = 0.85f; elevation = dp(8).toFloat()
    }
    private val addBtn = TextView(context).apply {
        text = "âž• Add Widget"; textSize = 16f
        setBackgroundColor(0xFF3F51B5.toInt()); setTextColor(0xFFFFFFFF.toInt())
        setPadding(dp(16), dp(8), dp(16), dp(8))
        layoutParams = LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.TOP or Gravity.CENTER_HORIZONTAL)
        elevation = dp(8).toFloat()
        setOnClickListener { showPicker() }
    }

    init {
        isClickable = true; isFocusable = true
        addView(canvas, LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT))
        addView(addBtn); addView(deleteZone)

        // Attach controller to the page's lifecycle (this is the androidx bit you now have)
        ViewTreeLifecycleOwner.get(this)?.lifecycle?.addObserver(controller)

        // Fallback if owner not yet available at init: register when attached.
        addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
            override fun onViewAttachedToWindow(v: View) {
                ViewTreeLifecycleOwner.get(this@WidgetPageView)?.lifecycle?.addObserver(controller)
            }
            override fun onViewDetachedFromWindow(v: View) { /* lifecycle removes observers automatically */ }
        })
    }

    private fun dp(v: Int) = (v * resources.displayMetrics.density).toInt()

    private fun showPicker() {
        WidgetPickerBottomSheet(
            context = context,
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            addWidget(provider, widgetId)
        }.show()
    }

    fun addWidget(provider: AppWidgetProviderInfo, widgetId: Int) {
        val w = max(provider.minWidth, 400)
        val h = max(provider.minHeight, 400)
        val hostView = appWidgetHost.createView(context, widgetId, provider).apply {
            setAppWidget(widgetId, provider)
            layoutParams = LayoutParams(w, h)
        }
        val container = FrameLayout(context).apply {
            layoutParams = LayoutParams(w, h)
            x = dp(100).toFloat(); y = dp(100).toFloat()
            addView(hostView)
            setOnTouchListener(touchListener(this, widgetId, provider))
        }
        canvas.addView(container)

        // Samsung: size negotiation AFTER layout (next frame) and after moves
        container.post { controller.applySize(hostView as AppWidgetHostView) }
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun touchListener(widget: View, widgetId: Int, provider: AppWidgetProviderInfo): OnTouchListener {
        var dX = 0f; var dY = 0f; var dragging = false
        return OnTouchListener { _, e ->
            when (e.action) {
                MotionEvent.ACTION_DOWN -> { dX = widget.x - e.rawX; dY = widget.y - e.rawY; dragging = false; true }
                MotionEvent.ACTION_MOVE -> { widget.x = e.rawX + dX; widget.y = e.rawY + dY; deleteZone.visibility = View.VISIBLE; dragging = true; true }
                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        Toast.makeText(context, "ðŸ—‘ï¸ Widget Removed", Toast.LENGTH_SHORT).show()
                    } else if (dragging) {
                        (widget.getChildAt(0) as? AppWidgetHostView)?.let { controller.applySize(it) }
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun isOverDeleteZone(view: View): Boolean {
        val zone = Rect()
        deleteZone.getGlobalVisibleRect(zone)
        val loc = IntArray(2); getLocationOnScreen(loc)
        val cx = (view.x + view.width / 2).toInt() + loc[0]
        val cy = (view.y + view.height / 2).toInt() + loc[1]
        return zone.contains(cx, cy)
    }
}



dependencies {
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.8.4"
    implementation "androidx.lifecycle:lifecycle-common-java8:2.8.4" // for DefaultLifecycleObserver
    // (optional but usual in pager+fragments projects)
    implementation "androidx.fragment:fragment-ktx:1.7.1"
    implementation "androidx.activity:activity-ktx:1.9.2"
}


import androidx.lifecycle.ViewTreeLifecycleOwner



dependencies {
    // EITHER use the BOM â€¦
    implementation(platform("androidx.lifecycle:lifecycle-bom:2.8.4"))
    implementation("androidx.lifecycle:lifecycle-runtime")          // <- contains ViewTreeLifecycleOwner
    implementation("androidx.lifecycle:lifecycle-runtime-ktx")      // optional
    implementation("androidx.lifecycle:lifecycle-common-java8")     // for DefaultLifecycleObserver

    // â€¦ OR pin the exact artifact:
    // implementation "androidx.lifecycle:lifecycle-runtime:2.8.4"
}











package your.package.name

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.view.Gravity
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.TextView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialog

/**
 * BottomSheet that shows live widget previews using a RecyclerView grid.
 * Allocation/binding happens on attach; resources are released on detach.
 */
class WidgetPickerBottomSheet(
    private val context: Context,
    private val appWidgetManager: AppWidgetManager,
    private val appWidgetHost: AppWidgetHost,
    private val onWidgetSelected: (AppWidgetProviderInfo, Int) -> Unit
) {

    fun show() {
        val sheet = BottomSheetDialog(context)
        val rv = RecyclerView(context).apply {
            layoutManager = GridLayoutManager(context, 2)
            setHasFixedSize(true)
        }

        val providers: List<AppWidgetProviderInfo> = appWidgetManager.installedProviders

        rv.adapter = object : RecyclerView.Adapter<WidgetCellVH>() {

            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): WidgetCellVH {
                val cellHeightPx = (200 * parent.resources.displayMetrics.density).toInt()
                val root = FrameLayout(parent.context).apply {
                    layoutParams = ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        cellHeightPx
                    )
                    isClickable = true
                }
                return WidgetCellVH(root)
            }

            override fun onBindViewHolder(holder: WidgetCellVH, position: Int) {
                holder.bind(providers[position], onWidgetSelected)
            }

            override fun getItemCount(): Int = providers.size

            // --- lifecycle-aware binding to avoid flicker/blank states ---
            override fun onViewAttachedToWindow(holder: WidgetCellVH) {
                holder.attach(appWidgetHost, appWidgetManager)
            }

            override fun onViewDetachedFromWindow(holder: WidgetCellVH) {
                holder.detach(appWidgetHost)
            }

            override fun onViewRecycled(holder: WidgetCellVH) {
                holder.detach(appWidgetHost)
                super.onViewRecycled(holder)
            }
        }

        sheet.setContentView(rv)
        sheet.show()
    }

    private class WidgetCellVH(val root: FrameLayout) : RecyclerView.ViewHolder(root) {
        private var provider: AppWidgetProviderInfo? = null
        private var widgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID
        private var hostView: AppWidgetHostView? = null

        fun bind(
            prov: AppWidgetProviderInfo,
            onPick: (AppWidgetProviderInfo, Int) -> Unit
        ) {
            provider = prov
            root.setOnClickListener {
                val id = if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID)
                    AppWidgetManager.INVALID_APPWIDGET_ID else widgetId
                // If we haven't attached yet, weâ€™ll allocate in attach();
                // if already attached, id is valid and we can return immediately.
                onPick(prov, if (id != AppWidgetManager.INVALID_APPWIDGET_ID) id else widgetId)
            }
        }

        fun attach(host: AppWidgetHost, mgr: AppWidgetManager) {
            val p = provider ?: return

            if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                widgetId = host.allocateAppWidgetId()
            }

            val bound = mgr.bindAppWidgetIdIfAllowed(widgetId, p.provider)

            root.removeAllViews()

            if (bound) {
                hostView = host.createView(root.context, widgetId, p).apply {
                    setAppWidget(widgetId, p)
                    layoutParams = FrameLayout.LayoutParams(p.minWidth, p.minHeight, Gravity.CENTER)
                }
                root.addView(hostView)
            } else {
                // Fallback label if user hasnâ€™t granted bind permission (non-system builds).
                root.addView(TextView(root.context).apply {
                    text = p.loadLabel(root.context.packageManager)
                    gravity = Gravity.CENTER
                    layoutParams = FrameLayout.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                })
            }
        }

        fun detach(host: AppWidgetHost) {
            root.removeAllViews()
            hostView = null
            if (widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                host.deleteAppWidgetId(widgetId)
                widgetId = AppWidgetManager.INVALID_APPWIDGET_ID
            }
        }
    }
}











package your.package.name

import android.annotation.SuppressLint
import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.graphics.Rect
import android.os.Bundle
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.Toast
import androidx.fragment.app.Fragment

/**
 * Fragment that owns the AppWidgetHost lifecycle and surface where a picked widget is placed.
 * Layout must define:
 *   - R.layout.widget_fragment_layout
 *   - a Button (or any clickable view) with id R.id.add_widget_button
 *   - a FrameLayout with id R.id.widgets_fragment_container (the canvas)
 */
class WidgetsFragment : Fragment(R.layout.widget_fragment_layout) {

    private lateinit var appWidgetManager: AppWidgetManager
    private lateinit var appWidgetHost: AppWidgetHost

    private lateinit var addWidgetBtn: View
    private lateinit var widgetsLayoutContainer: FrameLayout
    private lateinit var deleteZone: ImageView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        appWidgetManager = AppWidgetManager.getInstance(requireContext())
        appWidgetHost = AppWidgetHost(requireContext(), /*hostId=*/1024)
        // no startListening() here; do it in onStart()
    }

    override fun onStart() {
        super.onStart()
        appWidgetHost.startListening()
    }

    override fun onStop() {
        super.onStop()
        appWidgetHost.stopListening()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        addWidgetBtn = view.findViewById(R.id.add_widget_button)
        widgetsLayoutContainer = view.findViewById(R.id.widgets_fragment_container)

        // Optional: a simple bottom "trash" area for drag-to-delete.
        deleteZone = ImageView(requireContext()).apply {
            setImageResource(android.R.drawable.ic_menu_delete)
            alpha = 0.8f
            visibility = View.GONE
            layoutParams = FrameLayout.LayoutParams(
                resources.displayMetrics.widthPixels,
                (56 * resources.displayMetrics.density).toInt(),
                Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            )
        }
        (view as ViewGroup).addView(deleteZone)

        addWidgetBtn.setOnClickListener { showWidgetPickerBottomSheet() }
    }

    private fun showWidgetPickerBottomSheet() {
        WidgetPickerBottomSheet(
            context = requireActivity(),                 // Activity context is safer for some providers
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            // Called when user taps a cell in the sheet
            addWidgetToSurface(provider, widgetId)
        }.show()
    }

    private fun addWidgetToSurface(provider: AppWidgetProviderInfo, widgetId: Int) {
        // Ensure bound (no-op if already bound)
        if (!appWidgetManager.isBoundAppWidget(widgetId)) {
            val ok = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
            if (!ok) {
                Toast.makeText(requireContext(), "Binding not allowed", Toast.LENGTH_SHORT).show()
                return
            }
        }

        val hostView: AppWidgetHostView = appWidgetHost.createView(requireActivity(), widgetId, provider).apply {
            setAppWidget(widgetId, provider)
            layoutParams = FrameLayout.LayoutParams(provider.minWidth, provider.minHeight)
        }

        widgetsLayoutContainer.addView(hostView)

        // Optional: simple drag + delete interaction
        hostView.setOnTouchListener(widgetTouchListener(hostView, widgetId))
    }

    // --- Simple drag + delete (optional) ---

    @SuppressLint("ClickableViewAccessibility")
    private fun widgetTouchListener(widget: View, widgetId: Int): View.OnTouchListener {
        var dX = 0f
        var dY = 0f
        var dragging = false

        return View.OnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    dX = widget.x - event.rawX
                    dY = widget.y - event.rawY
                    dragging = false
                    true
                }

                MotionEvent.ACTION_MOVE -> {
                    widget.x = event.rawX + dX
                    widget.y = event.rawY + dY
                    deleteZone.visibility = View.VISIBLE
                    dragging = true
                    true
                }

                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (dragging && isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        appWidgetHost.deleteAppWidgetId(widgetId)
                        Toast.makeText(requireContext(), "Widget removed", Toast.LENGTH_SHORT).show()
                    }
                    true
                }

                else -> false
            }
        }
    }

    private fun isOverDeleteZone(v: View): Boolean {
        val trashRect = Rect()
        deleteZone.getHitRect(trashRect)
        val viewRect = Rect(
            v.x.toInt(), v.y.toInt(),
            (v.x + v.width).toInt(), (v.y + v.height).toInt()
        )
        return Rect.intersects(trashRect, viewRect)
    }
}

/** Helper: treat non-null info as â€œboundâ€. */
private fun AppWidgetManager.isBoundAppWidget(id: Int): Boolean = getAppWidgetInfo(id) != null















package your.package.name

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.util.Log
import android.view.Gravity
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.TextView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialog

/**
 * BottomSheet widget picker that shows live previews.
 * - Allocates/binds on attach; releases on detach.
 * - When user picks a cell, marks it "consumed" so the id survives sheet dismiss.
 */
class WidgetPickerBottomSheet(
    private val context: Context,
    private val appWidgetManager: AppWidgetManager,
    private val appWidgetHost: AppWidgetHost,
    private val onWidgetSelected: (AppWidgetProviderInfo, Int) -> Unit
) {
    private val tag = "WidgetPickerSheet"

    fun show() {
        val sheet = BottomSheetDialog(context)
        val rv = RecyclerView(context).apply {
            layoutManager = GridLayoutManager(context, 2)
            setHasFixedSize(true)
        }

        val providers: List<AppWidgetProviderInfo> = appWidgetManager.installedProviders

        rv.adapter = object : RecyclerView.Adapter<VH>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
                val cellHeightPx = (200 * parent.resources.displayMetrics.density).toInt()
                val root = FrameLayout(parent.context).apply {
                    layoutParams = ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        cellHeightPx
                    )
                    isClickable = true
                }
                return VH(root)
            }

            override fun onBindViewHolder(holder: VH, position: Int) {
                holder.bind(providers[position]) { prov, id ->
                    // 1) hand off the id to caller
                    onWidgetSelected(prov, id)
                    // 2) dismiss AFTER handoff (detach will run but skip deletion)
                    sheet.dismiss()
                }
            }

            override fun getItemCount() = providers.size

            override fun onViewAttachedToWindow(holder: VH) {
                holder.attach(appWidgetHost, appWidgetManager)
            }

            override fun onViewDetachedFromWindow(holder: VH) {
                holder.detach(appWidgetHost)
            }

            override fun onViewRecycled(holder: VH) {
                holder.detach(appWidgetHost)
                super.onViewRecycled(holder)
            }
        }

        sheet.setContentView(rv)
        sheet.show()
    }

    private inner class VH(val root: FrameLayout) : RecyclerView.ViewHolder(root) {
        private var provider: AppWidgetProviderInfo? = null
        private var widgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID
        private var hostView: AppWidgetHostView? = null

        /** If true, don't delete id on detach (user has picked this cell). */
        private var consumedByPick = false

        fun bind(
            prov: AppWidgetProviderInfo,
            onPick: (AppWidgetProviderInfo, Int) -> Unit
        ) {
            provider = prov
            consumedByPick = false

            root.setOnClickListener {
                val p = provider ?: return@setOnClickListener

                // If user taps before attach, allocate now.
                if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                    widgetId = appWidgetHost.allocateAppWidgetId()
                }

                // Try to bind silently; OK if false (Fragment will show system sheet).
                appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, p.provider)

                consumedByPick = true  // keep the id alive after dismiss
                onPick(p, widgetId)
            }
        }

        fun attach(host: AppWidgetHost, mgr: AppWidgetManager) {
            val p = provider ?: return

            if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                widgetId = host.allocateAppWidgetId()
                Log.d(tag, "allocate id=$widgetId for ${p.provider}")
            }

            val bound = mgr.bindAppWidgetIdIfAllowed(widgetId, p.provider)
            root.removeAllViews()

            if (bound) {
                hostView = host.createView(root.context, widgetId, p).apply {
                    setAppWidget(widgetId, p)
                    layoutParams = FrameLayout.LayoutParams(
                        p.minWidth, p.minHeight, Gravity.CENTER
                    )
                }
                root.addView(hostView)
            } else {
                // Fallback label if we can't bind silently (non-system app)
                root.addView(TextView(root.context).apply {
                    text = p.loadLabel(root.context.packageManager)
                    gravity = Gravity.CENTER
                    layoutParams = FrameLayout.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                })
            }
        }

        fun detach(host: AppWidgetHost) {
            root.removeAllViews()
            hostView = null
            if (!consumedByPick && widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                host.deleteAppWidgetId(widgetId)
                widgetId = AppWidgetManager.INVALID_APPWIDGET_ID
            }
        }
    }
}







package your.package.name

import android.annotation.SuppressLint
import android.app.Activity
import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Intent
import android.graphics.Rect
import android.os.Bundle
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.fragment.app.Fragment

/**
 * Fragment that owns the AppWidgetHost lifecycle and canvas for placed widgets.
 * Layout requirements:
 *  - R.layout.widget_fragment_layout
 *  - View id R.id.add_widget_button
 *  - FrameLayout id R.id.widgets_fragment_container
 */
class WidgetsFragment : Fragment(R.layout.widget_fragment_layout) {

    private lateinit var appWidgetManager: AppWidgetManager
    private lateinit var appWidgetHost: AppWidgetHost

    private lateinit var addWidgetBtn: View
    private lateinit var widgetsLayoutContainer: FrameLayout
    private lateinit var deleteZone: ImageView

    // Store pending selection when we need to ask system to grant bind permission
    private var pendingProvider: AppWidgetProviderInfo? = null
    private var pendingWidgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID

    // ActivityResult launcher for ACTION_APPWIDGET_BIND
    private val bindWidgetLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val id = result.data?.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1) ?: -1
            val info = if (id > 0) appWidgetManager.getAppWidgetInfo(id) else pendingProvider?.let {
                // Some OEMs don't echo back id; fall back to our pending id.
                appWidgetManager.getAppWidgetInfo(pendingWidgetId)
            }

            val finalId = if (id > 0) id else pendingWidgetId
            val finalInfo = info ?: pendingProvider
            if (finalInfo != null && finalId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                addWidgetToSurface(finalInfo, finalId)
            } else {
                Toast.makeText(requireContext(), "Binding canceled", Toast.LENGTH_SHORT).show()
            }
        } else {
            Toast.makeText(requireContext(), "Binding denied", Toast.LENGTH_SHORT).show()
        }

        // clear pending state
        pendingProvider = null
        pendingWidgetId = AppWidgetManager.INVALID_APPWIDGET_ID
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        appWidgetManager = AppWidgetManager.getInstance(requireContext())
        appWidgetHost = AppWidgetHost(requireContext(), /*hostId=*/1024)
    }

    override fun onStart() {
        super.onStart()
        appWidgetHost.startListening()
    }

    override fun onStop() {
        super.onStop()
        appWidgetHost.stopListening()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        addWidgetBtn = view.findViewById(R.id.add_widget_button)
        widgetsLayoutContainer = view.findViewById(R.id.widgets_fragment_container)

        // Optional trash zone for drag-to-delete
        deleteZone = ImageView(requireContext()).apply {
            setImageResource(android.R.drawable.ic_menu_delete)
            alpha = 0.85f
            visibility = View.GONE
            layoutParams = FrameLayout.LayoutParams(
                resources.displayMetrics.widthPixels,
                (56 * resources.displayMetrics.density).toInt(),
                Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            )
        }
        (view as ViewGroup).addView(deleteZone)

        addWidgetBtn.setOnClickListener { showWidgetPickerBottomSheet() }
    }

    private fun showWidgetPickerBottomSheet() {
        WidgetPickerBottomSheet(
            context = requireActivity(),
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            // Ensure we are allowed; if not, launch system grant UI.
            if (!ensureBindOrRequest(provider, widgetId)) return@WidgetPickerBottomSheet
            addWidgetToSurface(provider, widgetId)
        }.show()
    }

    /**
     * Try to bind silently; if not allowed, launch ACTION_APPWIDGET_BIND.
     * Returns true if already bound/allowed, false if flow continues via launcher.
     */
    private fun ensureBindOrRequest(provider: AppWidgetProviderInfo, widgetId: Int): Boolean {
        val ok = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
        if (ok) return true

        // Request user approval via system UI
        pendingProvider = provider
        pendingWidgetId = widgetId

        val intent = Intent(AppWidgetManager.ACTION_APPWIDGET_BIND).apply {
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widgetId)
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, provider.provider)
            // Optional: restrict to categories supported by the host
            // putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE, UserHandle.myUserId())
        }
        bindWidgetLauncher.launch(intent)
        return false
    }

    private fun addWidgetToSurface(provider: AppWidgetProviderInfo, widgetId: Int) {
        // Double-check bound (some OEMs require this even after approval)
        if (appWidgetManager.getAppWidgetInfo(widgetId) == null) {
            val ok = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
            if (!ok) {
                Toast.makeText(requireContext(), "Binding not allowed", Toast.LENGTH_SHORT).show()
                return
            }
        }

        val hostView: AppWidgetHostView =
            appWidgetHost.createView(requireActivity(), widgetId, provider).apply {
                setAppWidget(widgetId, provider)
                layoutParams = FrameLayout.LayoutParams(provider.minWidth, provider.minHeight)
            }

        widgetsLayoutContainer.addView(hostView)
        hostView.setOnTouchListener(widgetTouchListener(hostView, widgetId))
    }

    // ------------ Optional drag + delete UX ------------

    @SuppressLint("ClickableViewAccessibility")
    private fun widgetTouchListener(widget: View, widgetId: Int): View.OnTouchListener {
        var dX = 0f
        var dY = 0f
        var dragging = false

        return View.OnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    dX = widget.x - event.rawX
                    dY = widget.y - event.rawY
                    dragging = false
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    widget.x = event.rawX + dX
                    widget.y = event.rawY + dY
                    deleteZone.visibility = View.VISIBLE
                    dragging = true
                    true
                }
                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (dragging && isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        appWidgetHost.deleteAppWidgetId(widgetId)
                        Toast.makeText(requireContext(), "Widget removed", Toast.LENGTH_SHORT).show()
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun isOverDeleteZone(v: View): Boolean {
        val trashRect = Rect()
        deleteZone.getHitRect(trashRect)
        val viewRect = Rect(
            v.x.toInt(), v.y.toInt(),
            (v.x + v.width).toInt(), (v.y + v.height).toInt()
        )
        return Rect.intersects(trashRect, viewRect)
    }
}

----






package your.package.name

import android.annotation.SuppressLint
import android.app.Activity
import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Intent
import android.graphics.Rect
import android.os.Bundle
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.fragment.app.Fragment

/**
 * Fragment that owns the AppWidgetHost lifecycle and a canvas to place widgets.
 * Layout must include:
 *  - R.id.add_widget_button
 *  - R.id.widgets_fragment_container (FrameLayout)
 */
class WidgetsFragment : Fragment(R.layout.widget_fragment_layout) {

    private lateinit var appWidgetManager: AppWidgetManager
    private lateinit var appWidgetHost: AppWidgetHost

    private lateinit var addWidgetBtn: View
    private lateinit var widgetsLayoutContainer: FrameLayout
    private lateinit var deleteZone: ImageView

    private var pendingProvider: AppWidgetProviderInfo? = null
    private var pendingWidgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID

    private val bindWidgetLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val id = result.data?.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
                ?: pendingWidgetId
            val info = appWidgetManager.getAppWidgetInfo(id) ?: pendingProvider
            if (info != null && id != AppWidgetManager.INVALID_APPWIDGET_ID) {
                addWidgetToSurface(info, id)
            } else {
                Toast.makeText(requireContext(), "Binding canceled", Toast.LENGTH_SHORT).show()
            }
        } else {
            Toast.makeText(requireContext(), "Binding denied", Toast.LENGTH_SHORT).show()
        }
        pendingProvider = null
        pendingWidgetId = AppWidgetManager.INVALID_APPWIDGET_ID
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        appWidgetManager = AppWidgetManager.getInstance(requireContext())
        appWidgetHost = AppWidgetHost(requireContext(), /*hostId=*/1024)
    }

    override fun onStart() {
        super.onStart()
        appWidgetHost.startListening()
    }

    override fun onStop() {
        super.onStop()
        appWidgetHost.stopListening()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        addWidgetBtn = view.findViewById(R.id.add_widget_button)
        widgetsLayoutContainer = view.findViewById(R.id.widgets_fragment_container)

        // Simple bottom trash bar for drag-to-delete
        deleteZone = ImageView(requireContext()).apply {
            setImageResource(android.R.drawable.ic_menu_delete)
            alpha = 0.85f
            visibility = View.GONE
            layoutParams = FrameLayout.LayoutParams(
                resources.displayMetrics.widthPixels,
                (56 * resources.displayMetrics.density).toInt(),
                Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            )
        }
        (view as ViewGroup).addView(deleteZone)

        addWidgetBtn.setOnClickListener { showWidgetPickerBottomSheet() }
    }

    private fun showWidgetPickerBottomSheet() {
        WidgetPickerBottomSheet(
            context = requireActivity(), // activity context is safest for providers
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, widgetId ->
            if (!ensureBindOrRequest(provider, widgetId)) return@WidgetPickerBottomSheet
            addWidgetToSurface(provider, widgetId)
        }.show()
    }

    /** Try silent bind; if not allowed, launch system grant UI. */
    private fun ensureBindOrRequest(provider: AppWidgetProviderInfo, widgetId: Int): Boolean {
        val ok = appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, provider.provider)
        if (ok) return true

        pendingProvider = provider
        pendingWidgetId = widgetId

        val intent = Intent(AppWidgetManager.ACTION_APPWIDGET_BIND).apply {
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widgetId)
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, provider.provider)
        }
        bindWidgetLauncher.launch(intent)
        return false
    }

    private fun addWidgetToSurface(provider: AppWidgetProviderInfo, widgetId: Int) {
        // Some providers wonâ€™t draw until they get options (size in dp).
        val minWdp = maxOf(60, provider.minWidth)
        val minHdp = maxOf(60, provider.minHeight)

        val hostView: AppWidgetHostView =
            appWidgetHost.createView(requireActivity(), widgetId, provider).apply {
                setAppWidget(widgetId, provider)
                updateAppWidgetSize(Bundle(), minWdp, minHdp, minWdp, minHdp)
                layoutParams = FrameLayout.LayoutParams(
                    dp(200f), dp(200f) // start with a 200dp square; you can implement resize later
                )
            }

        widgetsLayoutContainer.addView(hostView)
        hostView.setOnTouchListener(widgetTouchListener(hostView, widgetId))
    }

    // --------- optional drag + delete ---------

    @SuppressLint("ClickableViewAccessibility")
    private fun widgetTouchListener(widget: View, widgetId: Int): View.OnTouchListener {
        var dX = 0f
        var dY = 0f
        var dragging = false

        return View.OnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    dX = widget.x - event.rawX
                    dY = widget.y - event.rawY
                    dragging = false
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    widget.x = event.rawX + dX
                    widget.y = event.rawY + dY
                    deleteZone.visibility = View.VISIBLE
                    dragging = true
                    true
                }
                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (dragging && isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        appWidgetHost.deleteAppWidgetId(widgetId)
                        Toast.makeText(requireContext(), "Widget removed", Toast.LENGTH_SHORT).show()
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun isOverDeleteZone(v: View): Boolean {
        val trashRect = Rect()
        deleteZone.getHitRect(trashRect)
        val viewRect = Rect(
            v.x.toInt(), v.y.toInt(),
            (v.x + v.width).toInt(), (v.y + v.height).toInt()
        )
        return Rect.intersects(trashRect, viewRect)
    }

    private fun dp(v: Float): Int = (v * resources.displayMetrics.density).toInt()
}









package your.package.name

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.content.ContextWrapper
import android.content.pm.PackageManager
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.util.Log
import android.view.Gravity
import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialog
import kotlin.math.roundToInt

/**
 * Widget picker that shows reliable previews:
 * - Uses correct dp/px conversion
 * - Calls updateAppWidgetSize() so providers can render
 * - Falls back to static preview (preview image/layout) when live preview isn't available
 * - Protects the picked widgetId from being deleted on dismiss
 */
class WidgetPickerBottomSheet(
    private val context: Context,
    private val appWidgetManager: AppWidgetManager,
    private val appWidgetHost: AppWidgetHost,
    private val onWidgetSelected: (AppWidgetProviderInfo, Int) -> Unit
) {
    private val tag = "WidgetPickerSheet"

    fun show() {
        val sheet = BottomSheetDialog(context)
        val rv = RecyclerView(context).apply {
            layoutManager = GridLayoutManager(context, 2)
            setHasFixedSize(true)
        }

        val providers: List<AppWidgetProviderInfo> = appWidgetManager.installedProviders

        rv.adapter = object : RecyclerView.Adapter<VH>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
                val cell = FrameLayout(parent.context).apply {
                    // ~200dp square cells (preview content is centered inside)
                    val size = dp(parent.context, 200f)
                    layoutParams = ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        size
                    )
                    isClickable = true
                    isFocusable = true
                    foreground = parent.context.obtainStyledAttributes(intArrayOf(android.R.attr.selectableItemBackground)).getDrawable(0)
                }
                return VH(cell)
            }

            override fun onBindViewHolder(holder: VH, position: Int) {
                holder.bind(providers[position]) { prov, id ->
                    onWidgetSelected(prov, id)
                    sheet.dismiss() // detach runs after this; holder protects the id
                }
            }

            override fun getItemCount() = providers.size

            override fun onViewAttachedToWindow(holder: VH) {
                holder.attach(appWidgetHost, appWidgetManager)
            }

            override fun onViewDetachedFromWindow(holder: VH) {
                holder.detach(appWidgetHost)
            }

            override fun onViewRecycled(holder: VH) {
                holder.detach(appWidgetHost)
                super.onViewRecycled(holder)
            }
        }

        sheet.setContentView(rv)
        sheet.show()
    }

    private inner class VH(val root: FrameLayout) : RecyclerView.ViewHolder(root) {
        private var provider: AppWidgetProviderInfo? = null
        private var widgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID
        private var hostView: AppWidgetHostView? = null
        private var consumedByPick = false

        fun bind(
            prov: AppWidgetProviderInfo,
            onPick: (AppWidgetProviderInfo, Int) -> Unit
        ) {
            provider = prov
            consumedByPick = false

            // Title above the preview
            root.removeAllViews()
            val title = TextView(root.context).apply {
                text = prov.loadLabel(root.context.packageManager)
                layoutParams = FrameLayout.LayoutParams(
                    ViewGroup.LayoutParams.WRAP_CONTENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT,
                    Gravity.START or Gravity.TOP
                ).apply { topMargin = dp(root.context, 8f) }
            }
            root.addView(title)

            // Placeholder; actual preview added during attach()
            val placeholder = FrameLayout(root.context).apply {
                val side = dp(root.context, 164f) // slightly smaller than cell
                layoutParams = FrameLayout.LayoutParams(side, side, Gravity.CENTER).apply {
                    topMargin = dp(root.context, 24f)
                }
                setBackgroundColor(0xFF333333.toInt())
            }
            root.addView(placeholder)

            root.setOnClickListener {
                val p = provider ?: return@setOnClickListener
                if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                    widgetId = appWidgetHost.allocateAppWidgetId()
                }
                // Attempt silent bind (no-op if already bound)
                appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, p.provider)

                consumedByPick = true
                onPick(p, widgetId)
            }
        }

        fun attach(host: AppWidgetHost, mgr: AppWidgetManager) {
            val p = provider ?: return
            val ctx = root.context

            if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                widgetId = host.allocateAppWidgetId()
            }

            root.post {
                // Remove old preview (if any)
                // Keep the first child (the title); remove others
                while (root.childCount > 1) root.removeViewAt(1)

                val bound = mgr.bindAppWidgetIdIfAllowed(widgetId, p.provider)
                if (bound && p.configure == null) {
                    // Live host view preview
                    val hv = host.createView(ctx, widgetId, p).apply {
                        setAppWidget(widgetId, p)
                        // Let provider know how big we are (expects dp!)
                        val minWdp = maxOf(60, p.minWidth)     // docs say these are in dp
                        val minHdp = maxOf(60, p.minHeight)
                        updateAppWidgetSize(Bundle(), minWdp, minHdp, minWdp, minHdp)
                        layoutParams = FrameLayout.LayoutParams(
                            dp(ctx, 164f),
                            dp(ctx, 164f),
                            Gravity.CENTER
                        ).apply { topMargin = dp(ctx, 24f) }
                    }
                    hostView = hv
                    root.addView(hv)
                } else {
                    // Static preview fallback (works for non-bound or config-required widgets)
                    val preview = staticPreview(ctx, p)
                    root.addView(preview)
                }
            }
        }

        fun detach(host: AppWidgetHost) {
            // Remove everything except the title (index 0)
            while (root.childCount > 1) root.removeViewAt(1)
            hostView = null
            if (!consumedByPick && widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                host.deleteAppWidgetId(widgetId)
                widgetId = AppWidgetManager.INVALID_APPWIDGET_ID
            }
        }

        private fun staticPreview(ctx: Context, p: AppWidgetProviderInfo): ImageView {
            val iv = ImageView(ctx).apply {
                scaleType = ImageView.ScaleType.CENTER_CROP
                layoutParams = FrameLayout.LayoutParams(
                    dp(ctx, 164f),
                    dp(ctx, 164f),
                    Gravity.CENTER
                ).apply { topMargin = dp(ctx, 24f) }
                setBackgroundColor(0xFF333333.toInt())
            }

            val d: Drawable? = try { p.loadPreviewImage(ctx, 0) } catch (e: Exception) { null }
            if (d != null) {
                iv.setImageDrawable(d)
                return iv
            }

            // If provider supplies previewLayout, inflate it inside the provider Context
            if (p.previewLayout != 0) {
                try {
                    val pkgCtx = ctx.createPackageContext(p.provider.packageName, 0)
                    val inflater = LayoutInflater.from(pkgCtx)
                    val view = inflater.inflate(p.previewLayout, null)
                    // Render that view into the ImageView's bitmap (simple draw cache)
                    view.measure(
                        ViewGroup.MeasureSpec.makeMeasureSpec(dp(ctx, 164f), ViewGroup.MeasureSpec.EXACTLY),
                        ViewGroup.MeasureSpec.makeMeasureSpec(dp(ctx, 164f), ViewGroup.MeasureSpec.EXACTLY)
                    )
                    view.layout(0, 0, view.measuredWidth, view.measuredHeight)
                    view.isDrawingCacheEnabled = true
                    val bmp = android.graphics.Bitmap.createBitmap(view.measuredWidth, view.measuredHeight, android.graphics.Bitmap.Config.ARGB_8888)
                    val canvas = android.graphics.Canvas(bmp)
                    view.draw(canvas)
                    iv.setImageBitmap(bmp)
                    return iv
                } catch (_: PackageManager.NameNotFoundException) {
                } catch (_: Throwable) {
                }
            }

            // Last resort: show label already added above; keep grey box
            return iv
        }
    }

    private fun dp(ctx: Context, v: Float): Int =
        (v * ctx.resources.displayMetrics.density).roundToInt()
}




G



package your.package.name

import android.annotation.SuppressLint
import android.app.Activity
import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.content.Intent
import android.graphics.Rect
import android.os.Bundle
import android.util.AttributeSet
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.result.ActivityResultCaller
import androidx.activity.result.contract.ActivityResultContracts
import your.package.name.databinding.LayoutWidgetsBinding

/**
 * A self-contained widget host surface:
 * - Owns AppWidgetHost/AppWidgetManager
 * - Launches WidgetPickerBottomSheet
 * - Requests ACTION_APPWIDGET_BIND when needed
 * - Places widgets and calls updateAppWidgetSize() so they render immediately
 *
 * Drop this view anywhere (your WidgetsPageLayout already does).
 */
class WidgetsLayout @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {

    private val vb: LayoutWidgetsBinding =
        LayoutWidgetsBinding.inflate(LayoutInflater.from(context), this, true)

    private val appWidgetManager: AppWidgetManager =
        AppWidgetManager.getInstance(context.applicationContext)

    // Keep hostId stable for your app
    private val appWidgetHost: AppWidgetHost = AppWidgetHost(context.applicationContext, 1024)

    private lateinit var canvas: FrameLayout
    private lateinit var addBtn: ImageButton
    private lateinit var deleteZone: ImageView

    // Pending state for ACTION_APPWIDGET_BIND
    private var pendingProvider: AppWidgetProviderInfo? = null
    private var pendingId: Int = AppWidgetManager.INVALID_APPWIDGET_ID

    // We need an ActivityResult launcher; obtain it from the Activity hosting this view.
    private val bindLauncher by lazy {
        val caller = hostActivity() as? ActivityResultCaller
            ?: error("Host Activity must implement ActivityResultCaller (ComponentActivity is fine).")
        caller.registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { r ->
            val id = r.data?.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
                ?: pendingId
            val info = appWidgetManager.getAppWidgetInfo(id) ?: pendingProvider
            if (r.resultCode == Activity.RESULT_OK &&
                info != null && id != AppWidgetManager.INVALID_APPWIDGET_ID) {
                placeWidget(info, id)
            } else {
                toast("Binding canceled/denied")
            }
            pendingProvider = null
            pendingId = AppWidgetManager.INVALID_APPWIDGET_ID
        }
    }

    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        // Start listening when this surface is visible
        appWidgetHost.startListening()

        canvas = vb.widgetsLayoutContainer
        addBtn = vb.addWidgetButton

        // Optional: bottom delete zone for drag-to-delete
        deleteZone = ImageView(context).apply {
            setImageResource(android.R.drawable.ic_menu_delete)
            alpha = 0.85f
            visibility = View.GONE
            layoutParams = LayoutParams(
                resources.displayMetrics.widthPixels,
                dp(56f),
                Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            )
        }
        addView(deleteZone)

        addBtn.setOnClickListener { openPicker() }
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        // Stop listening to save resources
        appWidgetHost.stopListening()
    }

    private fun openPicker() {
        WidgetPickerBottomSheet(
            context = hostActivity(),             // Activity context is safest
            appWidgetManager = appWidgetManager,
            appWidgetHost = appWidgetHost
        ) { provider, id ->
            if (!ensureBindOrRequest(provider, id)) return@WidgetPickerBottomSheet
            placeWidget(provider, id)
        }.show()
    }

    /** Try silent bind; else ask the system. */
    private fun ensureBindOrRequest(p: AppWidgetProviderInfo, id: Int): Boolean {
        val ok = appWidgetManager.bindAppWidgetIdIfAllowed(id, p.provider)
        if (ok) return true

        pendingProvider = p
        pendingId = id

        val intent = Intent(AppWidgetManager.ACTION_APPWIDGET_BIND).apply {
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, id)
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, p.provider)
        }
        bindLauncher.launch(intent)
        return false
    }

    /** Place on canvas and force immediate render via updateAppWidgetSize(). */
    private fun placeWidget(info: AppWidgetProviderInfo, id: Int) {
        val minWdp = maxOf(60, info.minWidth)   // values are in DP
        val minHdp = maxOf(60, info.minHeight)

        val hostView: AppWidgetHostView =
            appWidgetHost.createView(hostActivity(), id, info).apply {
                setAppWidget(id, info)
                updateAppWidgetSize(Bundle(), minWdp, minHdp, minWdp, minHdp)
                layoutParams = LayoutParams(dp(200f), dp(200f))
            }

        canvas.addView(hostView)
        hostView.setOnTouchListener(widgetTouchListener(hostView, id))
    }

    // ---- Optional drag & delete ----
    @SuppressLint("ClickableViewAccessibility")
    private fun widgetTouchListener(widget: View, widgetId: Int): OnTouchListener {
        var dX = 0f; var dY = 0f; var dragging = false
        return OnTouchListener { _, e ->
            when (e.action) {
                MotionEvent.ACTION_DOWN -> {
                    dX = widget.x - e.rawX
                    dY = widget.y - e.rawY
                    dragging = false
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    widget.x = e.rawX + dX
                    widget.y = e.rawY + dY
                    deleteZone.visibility = View.VISIBLE
                    dragging = true
                    true
                }
                MotionEvent.ACTION_UP -> {
                    deleteZone.visibility = View.GONE
                    if (dragging && isOverDeleteZone(widget)) {
                        (widget.parent as? ViewGroup)?.removeView(widget)
                        appWidgetHost.deleteAppWidgetId(widgetId)
                        toast("Widget removed")
                    }
                    true
                }
                else -> false
            }
        }
    }

    private fun isOverDeleteZone(v: View): Boolean {
        val trash = Rect(); deleteZone.getHitRect(trash)
        val r = Rect(v.x.toInt(), v.y.toInt(), (v.x + v.width).toInt(), (v.y + v.height).toInt())
        return Rect.intersects(trash, r)
    }

    private fun dp(v: Float): Int = (v * resources.displayMetrics.density).toInt()
    private fun toast(s: String) = Toast.makeText(context, s, Toast.LENGTH_SHORT).show()

    private fun hostActivity(): Activity {
        // This view is inside your page/activity; we need the real Activity
        var ctx = context
        while (ctx is android.content.ContextWrapper && ctx !is Activity) {
            ctx = ctx.baseContext
        }
        return ctx as Activity
    }
}



package your.package.name

import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetHostView
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialog
import kotlin.math.roundToInt

class WidgetPickerBottomSheet(
    private val context: Context,
    private val appWidgetManager: AppWidgetManager,
    private val appWidgetHost: AppWidgetHost,
    private val onWidgetSelected: (AppWidgetProviderInfo, Int) -> Unit
) {

    fun show() {
        val sheet = BottomSheetDialog(context)
        val rv = RecyclerView(context).apply {
            layoutManager = GridLayoutManager(context, 2)
            setHasFixedSize(true)
        }
        val providers = appWidgetManager.installedProviders

        rv.adapter = object : RecyclerView.Adapter<VH>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
                val root = FrameLayout(parent.context).apply {
                    val h = dp(parent.context, 200f)
                    layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, h)
                    isClickable = true
                    isFocusable = true
                }
                return VH(root)
            }

            override fun onBindViewHolder(h: VH, pos: Int) {
                h.bind(providers[pos]) { p, id ->
                    onWidgetSelected(p, id)
                    sheet.dismiss() // holder protects the id from deletion
                }
            }

            override fun getItemCount() = providers.size
            override fun onViewAttachedToWindow(h: VH) = h.attach(appWidgetHost, appWidgetManager)
            override fun onViewDetachedFromWindow(h: VH) = h.detach(appWidgetHost)
            override fun onViewRecycled(h: VH) { h.detach(appWidgetHost); super.onViewRecycled(h) }
        }

        sheet.setContentView(rv)
        sheet.show()
    }

    private inner class VH(val root: FrameLayout) : RecyclerView.ViewHolder(root) {
        private var provider: AppWidgetProviderInfo? = null
        private var widgetId: Int = AppWidgetManager.INVALID_APPWIDGET_ID
        private var hostView: AppWidgetHostView? = null
        private var consumedByPick = false

        fun bind(p: AppWidgetProviderInfo, onPick: (AppWidgetProviderInfo, Int) -> Unit) {
            provider = p
            consumedByPick = false
            root.removeAllViews()

            // Title
            root.addView(TextView(root.context).apply {
                text = p.loadLabel(root.context.packageManager)
                layoutParams = FrameLayout.LayoutParams(
                    ViewGroup.LayoutParams.WRAP_CONTENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT,
                    Gravity.START or Gravity.TOP
                ).apply { topMargin = dp(root.context, 8f) }
            })

            // Placeholder; real preview will be added in attach()
            root.addView(FrameLayout(root.context).apply {
                val side = dp(root.context, 164f)
                layoutParams = FrameLayout.LayoutParams(side, side, Gravity.CENTER).apply {
                    topMargin = dp(root.context, 24f)
                }
                setBackgroundColor(0xFF333333.toInt())
            })

            root.setOnClickListener {
                val prov = provider ?: return@setOnClickListener
                if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                    widgetId = appWidgetHost.allocateAppWidgetId()
                }
                appWidgetManager.bindAppWidgetIdIfAllowed(widgetId, prov.provider) // silent try
                consumedByPick = true
                onPick(prov, widgetId)
            }
        }

        fun attach(host: AppWidgetHost, mgr: AppWidgetManager) {
            val p = provider ?: return
            if (widgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
                widgetId = host.allocateAppWidgetId()
            }

            root.post {
                while (root.childCount > 1) root.removeViewAt(1)

                val bound = mgr.bindAppWidgetIdIfAllowed(widgetId, p.provider)
                if (bound && p.configure == null) {
                    val hv = host.createView(root.context, widgetId, p).apply {
                        setAppWidget(widgetId, p)
                        val wdp = maxOf(60, p.minWidth)
                        val hdp = maxOf(60, p.minHeight)
                        updateAppWidgetSize(Bundle(), wdp, hdp, wdp, hdp)
                        layoutParams = FrameLayout.LayoutParams(
                            dp(root.context, 164f),
                            dp(root.context, 164f),
                            Gravity.CENTER
                        ).apply { topMargin = dp(root.context, 24f) }
                    }
                    hostView = hv
                    root.addView(hv)
                } else {
                    root.addView(staticPreview(root.context, p))
                }
            }
        }

        fun detach(host: AppWidgetHost) {
            while (root.childCount > 1) root.removeViewAt(1)
            hostView = null
            if (!consumedByPick && widgetId != AppWidgetManager.INVALID_APPWIDGET_ID) {
                host.deleteAppWidgetId(widgetId)
                widgetId = AppWidgetManager.INVALID_APPWIDGET_ID
            }
        }

        private fun staticPreview(ctx: Context, p: AppWidgetProviderInfo): ImageView {
            val iv = ImageView(ctx).apply {
                scaleType = ImageView.ScaleType.CENTER_CROP
                layoutParams = FrameLayout.LayoutParams(
                    dp(ctx, 164f),
                    dp(ctx, 164f),
                    Gravity.CENTER
                ).apply { topMargin = dp(ctx, 24f) }
                setBackgroundColor(0xFF333333.toInt())
            }

            val d: Drawable? = try { p.loadPreviewImage(ctx, 0) } catch (_: Throwable) { null }
            if (d != null) { iv.setImageDrawable(d); return iv }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val layoutId = p.previewLayout
                if (layoutId != 0) {
                    try {
                        val pkgCtx = ctx.createPackageContext(p.provider.packageName, 0)
                        val view = LayoutInflater.from(pkgCtx).inflate(layoutId, null)
                        val side = dp(ctx, 164f)
                        view.measure(
                            View.MeasureSpec.makeMeasureSpec(side, View.MeasureSpec.EXACTLY),
                            View.MeasureSpec.makeMeasureSpec(side, View.MeasureSpec.EXACTLY)
                        )
                        view.layout(0, 0, side, side)
                        val bmp = Bitmap.createBitmap(side, side, Bitmap.Config.ARGB_8888)
                        val c = Canvas(bmp); view.draw(c)
                        iv.setImageBitmap(bmp)
                        return iv
                    } catch (_: PackageManager.NameNotFoundException) {
                    } catch (_: Throwable) {
                    }
                }
            }
            return iv
        }
    }

    private fun dp(ctx: Context, v: Float): Int =
        (v * ctx.resources.displayMetrics.density).roundToInt()
}




















H

package your.package.name

import android.app.Activity
import android.appwidget.AppWidgetHost
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProviderInfo
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.util.AttributeSet
import android.util.Log
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import androidx.activity.ComponentActivity
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.view.isVisible
import your.package.name.databinding.LayoutWidgetsBinding

class WidgetsLayout @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {

    companion object {
        private const val TAG = "WidgetsLayout"
        private const val APPWIDGET_HOST_ID = 1024
    }

    private lateinit var appWidgetManager: AppWidgetManager
    private lateinit var appWidgetHost: AppWidgetHost

    private lateinit var bindLauncher: ActivityResultLauncher<Intent>
    private var pendingId: Int = AppWidgetManager.INVALID_APPWIDGET_ID
    private var pendingProvider: AppWidgetProviderInfo? = null

    private var viewBinding: LayoutWidgetsBinding =
        LayoutWidgetsBinding.inflate(LayoutInflater.from(context), this, true)

    var canvas: FrameLayout = viewBinding.widgetsLayoutContainer
    var addBtn: ImageButton = viewBinding.addButton
    var deleteZone: ImageView = viewBinding.deleteZone

    /**
     * Call this from Activity.onCreate() before Activity STARTED
     */
    fun initLauncher(activity: ComponentActivity) {
        bindLauncher = activity.registerForActivityResult(
            ActivityResultContracts.StartActivityForResult()
        ) { r ->
            val id = r.data?.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, pendingId)
                ?: pendingId
            val info = appWidgetManager.getAppWidgetInfo(id) ?: pendingProvider
            if (r.resultCode == Activity.RESULT_OK &&
                info != null && id != AppWidgetManager.INVALID_APPWIDGET_ID
            ) {
                placeWidget(info, id)
            }
            pendingProvider = null
            pendingId = AppWidgetManager.INVALID_APPWIDGET_ID
        }
    }

    override fun onAttachedToWindow() {
        super.onAttachedToWindow()

        appWidgetManager = AppWidgetManager.getInstance(context)
        appWidgetHost = AppWidgetHost(context.applicationContext, APPWIDGET_HOST_ID)
        appWidgetHost.startListening()

        addBtn.isVisible = true
        addBtn.setOnClickListener {
            openWidgetPicker()
        }

        Log.i(TAG, "onAttachedToWindow: WidgetsLayout attached")
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        appWidgetHost.stopListening()
    }

    private fun openWidgetPicker() {
        val providers = appWidgetManager.installedProviders
        // For now, just take first provider to test
        val p = providers.firstOrNull() ?: return
        val id = appWidgetHost.allocateAppWidgetId()
        val bound = appWidgetManager.bindAppWidgetIdIfAllowed(id, p.provider)
        if (bound) {
            placeWidget(p, id)
        } else {
            pendingId = id
            pendingProvider = p
            val intent = Intent(AppWidgetManager.ACTION_APPWIDGET_BIND).apply {
                putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, id)
                putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, p.provider)
            }
            bindLauncher.launch(intent)
        }
    }

    private fun placeWidget(info: AppWidgetProviderInfo, id: Int) {
        val hostView = appWidgetHost.createView(context, id, info)
        val minW = info.minWidth
        val minH = info.minHeight
        val density = context.resources.displayMetrics.density
        val opts = Bundle().apply {
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, (minW / density).toInt())
            putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, (minH / density).toInt())
        }
        appWidgetManager.updateAppWidgetOptions(id, opts)
        hostView.setAppWidget(id, info)

        canvas.removeAllViews()
        canvas.addView(hostView)
    }
}




